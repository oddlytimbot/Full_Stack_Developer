## Intro to No-SQL

Getting to know Mongo can be made easier by breaking up the responsibilities into two categories. We need to know 1)how to manipulate data, and 2)how to present it

## Data Manipulation (CRUD)

The first thing we need to learn about Mongo is how to create databases, collections, and documents.

If you have followed the previous step, you have mongo installed and a superuser ready to go. Let's enter the interactive REPL for mongo with the following command:

`mongo admin -u admin -p admin`

This puts us into a mongo admin interactive shell that we can use to begin experimenting with mongo. The admin shell is useful for things like creating users.

The other way to enter the shell is through the regular mongo shell.

`mongo`

This shell is more usefull for working in databases and collections. It is also possible to do administration jobs by entering the "admin" database directly, authenticating as the admin user (that we set up during installation) and performing operations. To authenticate as the admin user:

```
use admin
db.autheticate("your_user", "your_password")
```

Success will show a response of 1.

### Creating a Database and User

Now that we are authenticated as the admin user, we can examine databases and add users to them.

`show dbs`

We will see that there are currently no databases. With schema-less databases such as mongo, it is common to imply schema. This relates to databases in that they are created at the time they are referenced. To make a database and have it stick around persistently the database needs to have at least one record put into it.

First we indicate the name of the database we wish to use.

`use students;`

Don't forget, we are still authenticated as the "admin" user. That user can can create users and grant them privliges but that is about all. If we want to work with our database, we need a user that will be an owner or have read/write persmissions.

```
db.createUser({user:"username", pwd:"password", roles[
    {
        role:"dbOwner",
        db: "students"
    }
]})
```
Now that the user is set up, we must authenticate as that user before we can do work.

```
use students
db.authenticate("username", "password");
db.showCollections
```

### Inserts

A schema-less database allows the insertion of records directly. In mongo, those records are organized as documents in collections. Documents are composed in JSON format.

Valid data types for mongo include strings, numbers, arrays and objects.

```
{
    firstName: "John"
    lastName: "Travolta"
    age: 40,
    tags: ["dancer", "singer", "actor"],
    description: {
        height: "5'4",
        weight: "200lbs"
    }
}
```

This "document" might be organized in a collection called "actors" inside our "entertainment" database.

```
use entertainment
db.actors.insert(
    {
        firstName: "John"
        lastName: "Travolta"
        age: 40,
        tags: ["dancer", "singer", "actor"],
        description: {
            height: "5'4",
            weight: "200lbs"
        }
    }
)
```

It is possible to insert multiple documents using array syntax.

```
db.actors.insert(
   [ {
        firstName: "John"
        lastName: "Travolta"
        age: 40,
        tags: ["dancer", "singer", "actor"],
        description: {
            height: "5'4",
            weight: "200lbs"
        }
    },
    {
        firstName: "Uma"
        lastName: "Thurman"
        age: 30,
        sex: "female",
        tags: ["dancer", "singer", "actor"],
        description: {
            height: "5'4",
            weight: "130lbs"
        }
    }

   ]
)
```

Note that in the example, the data is not uniform. The second actor document contains an extra property - the sex of the actor. This is fine in schema-less databases.

### Find Documents

Getting documents back out of the database involves using a 'find' operation on a collection. The find takes a query and returns JSON.

```
db.actors.find({firstName: "John"})
```
The query above will return ALL documents that contain a first name of "John", which may be quite a few records. It is better to query for a unique identifier, or limit results.

Notice that in the above query, an extra property has been added to the document, an "_id" that is auto-generated by mongo. This is a unique identifier.

$or, $gt, $lt

At this time, we should introduce the concept of operators. Operators allow us to be more specific with our queries to the database collections. For example, if we wanted to specify two options for finding actors, we could wrap our query in the $or operator, which accepts an array.

`db.actors.find({$or:[{firstName:"John"}, {firstName:"Uma"}]})`

The query above will return any actors with either the first name "John", or the first name "Uma". Cool right? What if we wanted to get results based on numeric queries? For example if we wanted to know what actors were older than 30? We have greater-than and less-than operators to work with.

`db.actors.find({age: {$gt:29} })`

....or actors named John over age 30

`db.actors.find({firstName:"John",{ age: {$gt:29} } })`

Could you write query that would retieve *either* actors named John or older than 30? (Hint: see the $or operator above)

#### Finding in Sub-Objects

We noted that an object is a valid type in Mongo. It is possible to query based on the content of sub-objects.

`db.actors.find({address.street:"Culver"})`

And it is possible to even search the content of array sub-objects. Where the document has an array of tags like `tags:["singer","actor"]` the following would return a result.

`db.actors.find({tags:"singer"})`

### Update Documents

update, $set, $unset, upsert, $rename

The update operation is a little deceptive. By default it will replace an entire document, rather than an individual field. For example:

`db.actors.update({firstName:"John"}, {gender:"male"})`

The first parameter is our query, used to identify the document we wish to edit. In this case we might expect the document to add in a "gender" property, but in fact what happens is the entire document is replaced with just the one property. Likely this is not what we want to do. Thankfully, we have operators that allow us to specify the behavior of the operation. Let's modify the operation above.

`db.actors.update({firstName:"John"},{ $set:{gender:"male"} })`

Operators wrap our data, and provide a powerful way to tell mongo specifics about how to treat the data. Another operator allows us to do increments on numeric values. Let's age John Travolta.

`db.actors.update({firstName:"John",lastName:"Travolta"}, {$inc:{age:1}})`

As you can imagine, the increment operator might be useful for any kind of voting or rating system.

Sometimes we may wish to completely remove a property from a document. In that case, the 'unset' operator is useful. We might remove the 'gender' property we added earlier.

`db.actors.update({firstName:"John",lastName:"Travolta"}, { $unset:{ gender:1  }})`

There is another operator that allows us to do an 'upsert'. This refers to an update operation that will either modify an existing document, or if there is no document found create it and add it to the collection. This option gets added as a third parameter to the 'update'.

`db.actors.update({firstName:"Mike",lastName:"Myers"}, {firstName:"Mike",lastName:"Myers", gender:"Male"}, {upsert:true} )`

And finally, it is possible to rename a property of a document if need be. For example if our data had gotten denormalized, with some people having a property 'sex' and some others a property 'gender' for the same data, we might rename one of the properties to normalize it.

`db.actors.update({sex:"Male"}, {$rename:{sex:"gender"}})`

### Remove Documents

The remove operation is not to be taken lightly! It uses the same query syntax as 'find' requests, and so can result in the removal of a lot of data from a collection very quickly.

To remove an actor, the request is almost the same as simply finding them.

`db.actors.remove({firstName:"John", lastName:"Travolta"})`

Just like that, he's gone!

If your intent was to remove a single document, there is a convenience option you can use to limit the removals.

`db.actors.remove({firstName:"John",lastName:"Travolta"}, { justOne:true } )`

## Data Presentation

sorting ascending

`db.actors.find().sort({age:1})`

sort descending

`db.actors.find().sort({age:-1})`

count

`db.actors.find().count()`

limit results

`db.actors.find().sort({age:1}).limit(10)`

forEach

#### Resources
[Medium Article](https://medium.com/@matteocontrini/how-to-setup-auth-in-mongodb-3-0-properly-86b60aeef7e8)